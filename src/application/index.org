#+TITLE: The Application Server
#+AUTHOR: VLEAD
#+DATE: [2016-05-11 Wed]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ../org-templates/level-1.org
#+options: ^:nil
#+LATEX: Literal LaTeX code for export


This document illustrates building of the application server.

* Initialization

** Some initialization and boilerplate code

*** __init__
#+BEGIN_SRC python :tangle ../src/__init__.py :eval no
print "src package"
import db
import app
import config
#+END_SRC

*** __init__ for Tests
#+BEGIN_SRC python :tangle ../tests/__init__.py :eval no
print "test package"
#+END_SRC




* Configuration

#+BEGIN_SRC python :tangle ../src/config.py :eval no
# DB URI
# example DB URI:
# mysql+oursql://scott:tiger@localhost/mydatabase
# postgresql+psycopg2://scott:tiger@localhost/mydatabase
SQLALCHEMY_DATABASE_URI = 'mysql+oursql://<userid>:<password>@<servername>/<db_name>'
# example
#SQLALCHEMY_DATABASE_URI = 'mysql+oursql://root:mysql@localhost/userdirectory'

# Debug from SQLAlchemy
# Turn this to False on production
SQLALCHEMY_ECHO = False
SQLALCHEMY_TRACK_MODIFICATIONS = True

# List of allowed origins for CORS
ALLOWED_ORIGINS = "['*']"

# List of allowed IPs
WHITELIST_IPS = ["127.0.0.1"]

# Configure your log paths
LOG_FILE_DIRECTORY = 'logs'
LOG_FILE = 'user-directory.log'

# Log level for the application
#10=DEBUG, 20=INFO, 30=WARNING, 40=ERROR, 50=CRITICAL",
LOG_LEVEL = 10

# APP_URL
APP_URL = "http://localhost:5000"

# Persona Verifier URL
PERSONA_VERIFIER_URL = "https://verifier.login.persona.org/verify"

#+END_SRC




* The web application
#+BEGIN_SRC python :tangle ../src/app.py :eval no
# -*- coding: utf-8 -*-
import os

from flask import Flask, jsonify, make_response
# from flask.ext.cors import CORS

from db import db
from api import api
# import config file
import config
from config import LOG_FILE_DIRECTORY
from config import LOG_FILE
from config import LOG_LEVEL


def create_app(config):
    # init our app
    app = Flask(__name__)
    app.secret_key = 'djfjsdkjXXS7979dfdfd'
    # load config values from the config file
    app.config.from_object(config)

    # init sqlalchemy db instance
    db.init_app(app)
    db.app = app
    # register blueprints
    app.register_blueprint(api)
    configure_logging(app)
    configure_errorhandlers(app)
    #  configure_cors(app)
    # all set; return app object
    return app


# custom error handlers to return JSON errors with appropiate status codes
def configure_errorhandlers(app):

    @app.errorhandler(500)
    def server_error(err):
        app.logger.error("error code = %s" % "500")
        resp = None
        try:
            app.logger.error("error desc = %s" % err.description)
            resp = make_response(jsonify(error=err.description), 500)
        except Exception:
            try:
                app.logger.error("error mesg = %s" % err.message)
                resp = make_response(jsonify(error=err.message), 500)
            except Exception:
                resp = make_response(jsonify(error=str(err)), 500)
                app.logger.error("error = %s" % str(err))
        return resp

    @app.errorhandler(405)
    def method_not_allowed(err):
        app.logger.error("error code = %s" % "405")
        resp = None
        try:
            app.logger.error("error desc = %s" % err.description)
            resp = make_response(jsonify(error=err.description), 405)
        except Exception:
            try:
                app.logger.error("error mesg = %s" % err.message)
                resp = make_response(jsonify(error=err.message), 405)
            except Exception:
                resp = make_response(jsonify(error=str(err)), 405)
                app.logger.error("error = %s" % str(err))
        return resp

    @app.errorhandler(404)
    def not_found(err):
        app.logger.error("error code = %s" % "404")
        resp = None
        try:
            app.logger.error("error desc = %s" % err.description)
            resp = make_response(jsonify(error=err.description), 404)
        except Exception:
            try:
                app.logger.error("error mesg = %s" % err.message)
                resp = make_response(jsonify(error=err.message), 404)
            except Exception:
                resp = make_response(jsonify(error=str(err)), 404)
                app.logger.error("error = %s" % str(err))
        return resp

    @app.errorhandler(400)
    def bad_request(err):
        app.logger.error("error code = %s" % "400")
        resp = None
        try:
            app.logger.error("error desc = %s" % err.description)
            resp = make_response(jsonify(error=err.description), 400)
        except Exception:
            try:
                app.logger.error("error mesg = %s" % err.message)
                resp = make_response(jsonify(error=err.message), 400)
            except Exception:
                resp = make_response(jsonify(error=str(err)), 400)
                app.logger.error("error = %s" % str(err))
        return resp


def configure_logging(app):
    import logging
    import logging.handlers
    formatter = logging.Formatter('%(asctime)s: %(levelname)s: %(filename)s:'
                                  ' %(funcName)s():%(lineno)d: %(message)s')

    # Also error can be sent out via email. So we can also have a SMTPHandler?
    log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                           '..',
                           LOG_FILE_DIRECTORY)

    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    log_file = "%s/%s" % (log_dir, LOG_FILE)
    os.system("sudo touch %s" % log_file)
    os.system("sudo chmod 777 %s" % log_file)
    max_size = 1024 * 1024 * 20  # Max Size for a log file: 20MB
    log_handler = logging.handlers.RotatingFileHandler(log_file,
                                                       maxBytes=max_size,
                                                       backupCount=10)

    log_level = LOG_LEVEL
    log_handler.setFormatter(formatter)

    app.logger.addHandler(log_handler)
    app.logger.setLevel(log_level)

if __name__ == "__main__":
    app = create_app(config)
    app.run(debug=True, host='0.0.0.0', threaded=True)
#+END_SRC



* REST

** Initialization
#+BEGIN_SRC python :tangle ../src/api.py :eval no

# -*- coding: utf-8 -*-

import os
import csv
import requests
from datetime import datetime
import inspect
from flask import session, render_template, Blueprint, request, jsonify, abort,\
    current_app, redirect, url_for
from config import *
from flask import current_app

from flask import Flask, redirect, url_for
from werkzeug import secure_filename

from db import *
from utils import parse_request, jsonify_list
api = Blueprint('APIs', __name__)
#+END_SRC


** GET all users

#+BEGIN_SRC python :tangle ../src/api.py :eval no
@api.route('/users', methods=['GET'])
def get_users():
    return jsonify_list([i.to_client() for i in User.get_all()])
#+END_SRC
   

** GET all roles
   The is the REST API to get all the roles.

#+BEGIN_SRC python :tangle ../src/api.py :eval no
@api.route('/roles', methods=['GET'])
def get_roles():
    return jsonify_list([i.to_client() for i in Role.get_all()])
#+END_SRC


** GET a user with id

#+BEGIN_SRC python :tangle ../src/api.py :eval no
@api.route('/users/<int:id>', methods=['GET'])
def get_user_by_id(id):
    record = User.get_by_id(id)
    if not record:
        abort(404, "No entry for %s with id: %s found." % ("user", id))

    return jsonify(record.to_client())
#+END_SRC


** GET a role with id

#+BEGIN_SRC python :tangle ../src/api.py :eval no
@api.route('/roles/<int:id>', methods=['GET'])
def get_role_by_id(id):
    record = Role.get_by_id(id)
    if not record:
        abort(404, "No entry for %s with id: %s found." % ("role", id))

    return jsonify(record.to_client())
#+END_SRC


** Create a user
   Usage:
   #+BEGIN_EXAMPLE
   POST request
   {
   "name": "Jimi hendrix",
   "email": "jimi@gmail.com",
   "roles": [1,2]
   }

    OR
   
    {
    "name": "Jimi hendrix",
    "email": "jimi@gmail.com",
    }
   #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../src/api.py :eval no
@api.route('/users', methods=['POST'])
def create_user():
    if not request.json or not 'name' in request.json or not 'email' in request.json:
        abort(400)
    else:
        name = request.json['name']
        email = request.json['email']
        role_ids = []
        roles = []
        if 'roles' in request.json:
            role_ids = request.json['roles']
        try:
            for role_id in role_ids:
                roles.append(Role.get_by_id(role_id))
            user = User(name=Name(name),
                        email=Email(email),
                        roles=roles)
            user.save()
            return jsonify(user.to_client())
        except Exception, e:
            current_app.logger.error("Error occured while inserting"
                                     "user record: %s" % str(e))
            abort(500, str(e))
                
                
#+END_SRC

** Create a role

#+BEGIN_SRC python :tangle ../src/api.py :eval no

@api.route('/roles', methods=['POST'])
def create_role():
    if not request.json or not 'name' in request.json:
        abort(400)
    else:
        name = request.json['name']
        try:
            role = Role(name=Name(name))
            role.save()
            return jsonify(role.to_client())
        except Exception, e:
            current_app.logger.error("Error occured while inserting" 
                                     "role record: %s" % str(e))
            abort(500, str(e))

#+END_SRC

** Update a user

#+BEGIN_SRC python :tangle ../src/api.py :eval no
@api.route('/users/<int:id>', methods=['PUT', 'DELETE'])
def update_delete_user(id):

    record = User.get_by_id(id)

    if not record:
        abort(404, 'No %s with id %s' % (user, id))

    if request.method == 'DELETE':
        try:
            record.delete()
            return jsonify(id=id, status="success")
        except Exception, e:
            current_app.logger.error("Error occured while deleting"
                                     "user record %d: %s" % (id, str(e)))
            abort(500, str(e))

    if request.method == 'PUT':

        new_data = {}
        try:
            if 'name' in request.json:
                new_data['name'] = Name(request.json['name'])
            if 'email' in request.json:
                new_data['email'] = Email(request.json['email'])
            if 'roles' in request.json:
                role_ids = request.json['roles']
                roles = []
                for role_id in role_ids:
                    roles.append(Role.get_by_id(role_id))
                new_data['roles'] = roles

            record.update(**new_data)

            return jsonify(User.get_by_id(id).to_client())

        except Exception, e:
            current_app.logger.error("Error occured while updating"
                                     "user record %d: %s" % (id, str(e)))
            abort(500, str(e))
#+END_SRC

** Update a role
#+BEGIN_SRC python :tangle ../src/api.py :eval no
@api.route('/roles/<int:id>', methods=['PUT', 'DELETE'])
def update_delete_role(id):

    record = Role.get_by_id(id)

    if not record:
        abort(404, 'No %s with id %s' % (role, id))

    if request.method == 'DELETE':
        try:
            record.delete()
            return jsonify(id=id, status="success")
        except Exception, e:
            current_app.logger.error("Error occured while deleting "
                                     "role record %d: %s" % (id, str(e)))
            abort(500, str(e))

    if request.method == 'PUT':

        new_data = {}
        try:
            if 'name' in request.json:
                new_data['name'] = Name(request.json['name'])

            record.update(**new_data)

            return jsonify(Role.get_by_id(id).to_client())

        except Exception, e:
            current_app.logger.error("Error occured while updating "
                                     "role record %d: %s" % (id, str(e)))
            abort(500, str(e))
#+END_SRC
** Delete a user


** Delete a role
