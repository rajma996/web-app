#+title:  Object  Implementation of Mini Version of User Directory Application
#+AUTHOR: VLEAD
#+DATE: [2016-05-11 Wed]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ../../../org-templates/level-0.org
#+options: ^:nil
#+LATEX: Literal LaTeX code for export


* Initialization
  
** Imports for Python API
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
# -*- coding: utf-8 -*-
from op_exceptions import AttributeRequired
from op_exceptions import ConstraintError
from utils import *
#+END_SRC


** Imports and Initialization of testcases for Python API

#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
# -*- coding: utf-8 -*-
import unittest
from unittest import TestCase
from datetime import datetime

from src.obj import *
from src.op_exceptions import AttributeRequired
from src.op_exceptions import ConstraintError

#+END_SRC


** Imports for utility functions

#+BEGIN_SRC python :tangle ../../src/utils.py :eval no

# module to hold all utilities/helper functions

import json

import re


#+END_SRC


** Init Files
#+BEGIN_SRC python :tangle ../../src/__init__.py :eval no
import obj
#+END_SRC

#+BEGIN_SRC python :tangle ../../tests/__init__.py :eval no
print "tests package"
#+END_SRC



* Object Model

** Custom Exceptions
   These are some of the custom exceptions used in the application.

*** AttributeRequired

#+BEGIN_SRC python :tangle ../../src/op_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)
#+END_SRC

*** ConstraintError
#+BEGIN_SRC python :tangle ../../src/op_exceptions.py :eval no
class ConstraintError(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)


#+END_SRC




** Utility Functions

*** is_alphabetic_string(value)
    This function take an argument and checks whether the argument contains
    only alphabets.

#+BEGIN_SRC  python :tangle ../../src/utils.py :eval no
def is_alphabetic_string(value):
    if re.search('[^a-zA-Z. ]+', value):
        return False
    else:
        return True
#+END_SRC


*** is_email(value)
    Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
    Following is the constructor for this class.

#+BEGIN_SRC python :tangle ../../src/utils.py :eval no
def is_email(value):
    if re.search('[^@]+@[^@]+\.[^@]+', value):
        return True
    else:
        return False
#+END_SRC

*** is_role(value):
#+BEGIN_SRC python :tangle ../../src/utils.py :eval no
def is_role(value):
    if value == "admin" or value == "normal":
        return True
    else :
        return False
#+END_SRC
        

** Name

*** Construction

     Name is an alphabetical string.

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Name(object):
    value = None
    def __init__(self, value):
        # value: String 
        # if the string contains any non-alphabet and non-space character,
        # raise a type error
        if is_alphabetic_string(value):
            self.value = value
        else:
            raise TypeError('%s is not a Name!' % value)

    def __str__(self):
        return self.value
#+END_SRC


*** Test the Construction
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestName(TestCase):
    TESTING = True
    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")
#+END_SRC


** Email

*** Construction

     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Email(object):
    value = None
    def __init__(self, value):
        if is_email(value) :
           self.value = value
        else :
           raise TypeError('%s is not a Email!' % value)

    def __str__(self):
        return self.value
        
#+END_SRC

*** Test the Construction
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestEmail(TestCase):
    TESTING = True
    def test_email_type(self):
        print "test_email_type"
        new_email = Email("Johnw@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "Johnw@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "sdfsdfsdfsfsdf")
#+END_SRC

** User

*** Mutable Data

     These are the data associated with User type, which are mutable

     + Name
     + Email
     + Role

       
*** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class User():
    users = []     # this is a static variable, accessed by User.users
    email = None
    name = None
    role = None
#+END_SRC


*** Constructor

**** Implementation

    Signature of the constructor of =User= is as follows:

    #+BEGIN_EXAMPLE
    usr = User(name=<object of Name>, email=<object of Email>, 
              role=[<object of Role>, <object of Role> ...])
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def __init__(self, kwargs):
        if 'name' not in kwargs or 'email' not in kwargs or 'role' not in kwargs:
            raise AttributeError("argument should be a dict with keys name, email and role")

        elif not isinstance(kwargs['name'],Name)  :
            raise AttributeError("name key must have an instance of Name class")

        elif not isinstance(kwargs['email'],Email)  :
            raise AttributeError("email key must have an instance of Email class")

        elif not isinstance(kwargs['role'],Role)  :
            raise AttributeError("role key must have an instance of Role class")

        else :
            self.name = kwargs['name']
            self.email = kwargs['email']
            self.role = kwargs['role']
           
#+END_SRC


**** Test the constructor
 #+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestUser(TestCase):
    TESTING = True

    def test_user_creation_without_role(self):
        temp = {'name': Name('john'), 'email': Email('john@gmail.com')}
        self.assertRaises(AttributeError,User , temp )

    def test_user_creation_with_role(self):
        temp = {'name': Name('john'), 'email': Email('john@gmail.com') , 'role': Role('admin') }
        inst = User(temp)
        self.assertEqual(inst.get_name(),'john')
        self.assertEqual(inst.get_email(),'john@gmail.com')
        self.assertEqual(inst.get_role(),'admin')



#+END_SRC


*** Functions
    
**** setEmail
***** Implementaion
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_email(self, email):
        if isinstance(email,Email):
            self.email = email
        else :
            raise TypeError('argument must be an istance of email class')

#+END_SRC

***** Test
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_setemail(self):
        temp = {'name': Name('john'), 'email': Email('john@gmail.com') , 'role': Role('admin') }
        inst = User(temp)
        self.assertEqual(inst.get_email(),'john@gmail.com')
        inst.set_email(Email('john123@gmail.com'));
        self.assertEqual(inst.get_email(),'john123@gmail.com')
#+END_SRC
**** adduser
***** Implementaion
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def add_user(self):
        for i in range(0,len(User.users)):
            if User.users[i].email.value == self.email.value:
                raise ConstraintError ("Email id must be unique")
                return

        User.users.append(self);

#        if existing_user :
#            raise ConstraintError ("Email id must be unique")
#        else :
#            User.users.append(self)

#+END_SRC

***** Test
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_adduser(self):
        temp = {'name': Name('john'), 'email': Email('john@gmail.com') , 'role': Role('admin') }
        temp1 = {'name': Name('johnsnow'), 'email': Email('john@gmail.com') , 'role': Role('admin') }
        inst = User(temp)
        inst1 = User(temp1)
        inst.add_user();
        print User.users[0].email.value
        with self.assertRaises(ConstraintError):
            inst1.add_user();
#+END_SRC
**** setName
***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_name(self, name):
        if isinstance(name,Name):
            self.name = name;
        else :
            raise TypeError('argument must be an istance of Name class')
        
#+END_SRC
***** Test
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_setname(self):
        temp = {'name': Name('john'), 'email': Email('john@gmail.com') , 'role': Role('admin') }
        inst = User(temp)
        self.assertEqual(inst.get_name(),'john')
        inst.set_name(Name('johnsnow'));
        self.assertEqual(inst.get_name(),'johnsnow')
#+END_SRC
**** setRole
***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_role(self, role):
        if isinstance(role,Role):
            self.role = role;
        else :
            raise TypeError('attribute must be an istance of Role class')

#+END_SRC
***** Test

**** getRole
***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_role(self):
        return self.role.value
#+END_SRC
***** Test


**** getEmail
 #+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_email(self):
        return self.email.value
 #+END_SRC

 
**** getName
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_name(self):
        return self.name.value
#+END_SRC


**** getAll: Nil --> set[User]

***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def get_all():
        return User.users
#+END_SRC


***** Test getAll
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_user_get_all(self):
        print "test_user_get_all"

#+END_SRC


**** toClient
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def to_client(self):
        pass
#        return {
#            'name': self.name,
#            'email': self.email,
#            'role': self.role.to_client()
#        }
#+END_SRC



** Role

*** Introduction
   A Role has got certain privileges.  In this current application, the
   privileges are understood 
   
   Different types of roles are:
   - Admin :: An admin is an user who can add, modify and delete other users
        except himself.
   - User :: A User is a user who can view all other users and can modify himself.


*** Mutable Data

     These are the data associated with Role type, which are mutable

     + Name


*** Definition
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
class Role():
    value = None
#+END_SRC


*** Constructor

    The signature of Role is defined as follows
    #+BEGIN_EXAMPLE
    role = Role("admin")
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def __init__(self, string):
        if is_role(string)==False:
            raise TypeError("Role can be admin or normal")
        else :
            self.value = string
#+END_SRC

*** Test Constructor
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
class TestRole(TestCase):
    TESTING = True
    def test_role_creation(self):
        print "test_role"
        new_name = Name("admin")
        # correct name
        self.assertEqual(new_name.value, "admin")
        # incorrect name
        self.assertRaises(TypeError, Role, "adminnormal")
#+END_SRC


*** Functions

**** setrole
***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def set_role(self, name):
        if is_role(name)==False :
            raise TypeError("role can be admin or normal")
        else :
            self.value = name
#+END_SRC

****** Test
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_role_set_name(self):
        temp_role = Role('admin')
        self.assertEqual(temp_role.value,'admin')
        temp_role.set_role('normal')
        self.assertEqual(temp_role.value,'normal')
#+END_SRC


**** getrole

#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def get_role(self):
        return self.value
#+END_SRC


**** getAll: Nil --> set[Role]

***** Implementation
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    @staticmethod
    def get_all():
#        return ('admin','normal')
        pass
#+END_SRC


***** Test getAll: Nil --> set[Role]
 #+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
    def test_role_get_all(self):
        temp_role = Role('admin')
        #self.assertEqual(temp_role.get_all(),('admin','normal'))
 #+END_SRC


**** to_client
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def to_client(self):
        print "fill"
#+END_SRC



* Run Test Cases
 
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no
if __name__ == '__main__':
    unittest.main()
#+END_SRC



